# -*- coding: utf-8 -*-
"""PartC.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WD3Fh4vOFHGoeKKtqMTrYQcy_TtO0oMM
"""

import datetime
from typing import List, Dict, Union, Set


def print_onebanc_banner():
    """Print the OneBanc MPIN Task banner"""
    banner = """
 ██████╗ ███╗   ██╗███████╗██████╗  █████╗ ███╗   ██╗ ██████╗
██╔═══██╗████╗  ██║██╔════╝██╔══██╗██╔══██╗████╗  ██║██╔════╝
██║   ██║██╔██╗ ██║█████╗  ██████╔╝███████║██╔██╗ ██║██║
██║   ██║██║╚██╗██║██╔══╝  ██╔══██╗██╔══██║██║╚██╗██║██║
╚██████╔╝██║ ╚████║███████╗██████╔╝██║  ██║██║ ╚████║╚██████╗
 ╚═════╝ ╚═╝  ╚═══╝╚══════╝╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═══╝ ╚═════╝

███╗   ███╗██████╗ ██╗███╗   ██╗    ██╗   ██╗ █████╗ ██╗     ██╗██████╗  █████╗ ████████╗ ██████╗ ██████╗
████╗ ████║██╔══██╗██║████╗  ██║    ██║   ██║██╔══██╗██║     ██║██╔══██╗██╔══██╗╚══██╔══╝██╔═══██╗██╔══██╗
██╔████╔██║██████╔╝██║██╔██╗ ██║    ██║   ██║███████║██║     ██║██║  ██║███████║   ██║   ██║   ██║██████╔╝
██║╚██╔╝██║██╔═══╝ ██║██║╚██╗██║    ╚██╗ ██╔╝██╔══██║██║     ██║██║  ██║██╔══██║   ██║   ██║   ██║██╔══██╗
██║ ╚═╝ ██║██║     ██║██║ ╚████║     ╚████╔╝ ██║  ██║███████╗██║██████╔╝██║  ██║   ██║   ╚██████╔╝██║  ██║
╚═╝     ╚═╝╚═╝     ╚═╝╚═╝  ╚═══╝      ╚═══╝  ╚═╝  ╚═╝╚══════╝╚═╝╚═════╝ ╚═╝  ╚═╝   ╚═╝    ╚═════╝ ╚═╝  ╚═╝
"""
    print(banner)


class MPINValidator:
    """
    Class to validate if a 4-digit MPIN is weak or strong based on pattern analysis.
    Uses only logical pattern detection techniques without predefined lists.
    """

    def __init__(self):
        """Initialize the MPIN validator with pattern detection methods"""
        # Define pattern detectors using only logic
        self.pattern_detectors = [
            self._is_sequential,
            self._is_repeated_digits,
            self._is_palindrome,
            self._is_all_same_digit,
            self._is_common_year,
            self._has_repeating_pattern,
            self._has_limited_unique_digits,
            self._is_all_even_or_odd,
            self._has_arithmetic_progression,
            self._has_symmetrical_pattern,
            self._has_digit_pairs
        ]

    def _is_sequential(self, mpin: str) -> bool:
        """
        Check if MPIN has sequential digits (ascending or descending).
        Uses logic to check if each digit differs from the previous by +1 or -1.
        """
        # Check for standard sequential patterns
        digits = [int(d) for d in mpin]

        # Check ascending (e.g., 1234, 4567)
        ascending = True
        for i in range(len(digits) - 1):
            if digits[i+1] != (digits[i] + 1) % 10:  # Use modulo for circular sequence (e.g., 9012)
                ascending = False
                break

        # Check descending (e.g., 4321, 7654)
        descending = True
        for i in range(len(digits) - 1):
            if digits[i+1] != (digits[i] - 1) % 10:  # Use modulo for circular sequence (e.g., 1098)
                descending = False
                break

        return ascending or descending

    def _is_repeated_digits(self, mpin: str) -> bool:
        """
        Check if MPIN has a repeating pattern like ABAB.
        Uses logic to detect if the first half repeats in the second half.
        """
        half_len = len(mpin) // 2
        if mpin[:half_len] == mpin[half_len:]:
            return True
        return False

    def _is_palindrome(self, mpin: str) -> bool:
        """
        Check if MPIN is a palindrome (reads the same backward as forward).
        Uses logic to test if the string equals its reverse.
        """
        return mpin == mpin[::-1]

    def _is_all_same_digit(self, mpin: str) -> bool:
        """
        Check if all digits in MPIN are the same.
        Uses logic to count unique digits.
        """
        return len(set(mpin)) == 1

    def _is_common_year(self, mpin: str) -> bool:
        """
        Check if MPIN represents a common year (19xx or 20xx).
        Uses logic to check if the PIN falls within a plausible year range.
        """
        if len(mpin) == 4 and (mpin.startswith('19') or mpin.startswith('20')):
            try:
                year = int(mpin)
                current_year = datetime.datetime.now().year
                if 1930 <= year <= current_year:
                    return True
            except ValueError:
                pass
        return False

    def _has_repeating_pattern(self, mpin: str) -> bool:
        """
        Check for repeating patterns within the MPIN.
        Uses logic to detect patterns like AABB, AAAB, etc.
        """
        # Check for patterns where groups of 2 digits repeat
        if len(mpin) == 4 and mpin[0:2] == mpin[2:4]:
            return True

        # Check for patterns like AABC, ABCC, etc.
        for digit in set(mpin):
            if mpin.count(digit) >= 3:
                return True

        return False

    def _has_limited_unique_digits(self, mpin: str) -> bool:
        """
        Check if MPIN has very few unique digits (1 or 2).
        Uses logic to count unique digits.
        """
        return len(set(mpin)) <= 2

    def _is_all_even_or_odd(self, mpin: str) -> bool:
        """
        Check if all digits in the MPIN are either all even or all odd.
        """
        # Convert string to list of integers
        digits = [int(d) for d in mpin]

        # Check if all digits are even
        all_even = all(d % 2 == 0 for d in digits)

        # Check if all digits are odd
        all_odd = all(d % 2 == 1 for d in digits)

        return all_even or all_odd

    def _has_arithmetic_progression(self, mpin: str) -> bool:
        """
        Check if digits form an arithmetic progression (e.g., 2468, 8642, 1357, 7531).
        """
        digits = [int(d) for d in mpin]

        # Skip check if less than 3 unique digits (covered by other detectors)
        if len(set(digits)) < 3:
            return False

        # Check for constant difference between consecutive digits
        differences = [digits[i+1] - digits[i] for i in range(len(digits)-1)]

        # If all differences are the same and not 0, it's an arithmetic progression
        return len(set(differences)) == 1 and differences[0] != 0

    def _has_symmetrical_pattern(self, mpin: str) -> bool:
        """
        Check for symmetrical patterns like 1221, 1331, 2442, etc.
        """
        # First and last digits are the same, and the two middle digits are the same
        if len(mpin) == 4:
            return (mpin[0] == mpin[3]) and (mpin[1] == mpin[2])
        return False

    def _has_digit_pairs(self, mpin: str) -> bool:
        """
        Check if MPIN consists of digit pairs (e.g., 1122, 9944, 5566).
        """
        if len(mpin) == 4:
            return mpin[0] == mpin[1] and mpin[2] == mpin[3] and mpin[0] != mpin[2]
        return False

    def is_weak_mpin(self, mpin: str) -> bool:
        """
        Determine if the provided MPIN is weak based on pattern analysis.

        Args:
            mpin (str): A 4-digit MPIN

        Returns:
            bool: True if the MPIN is weak, False if strong
        """
        # Basic validation
        if not isinstance(mpin, str) or not mpin.isdigit() or len(mpin) != 4:
            raise ValueError("MPIN must be a 4-digit string")

        # Run through pattern detectors
        for detector in self.pattern_detectors:
            if detector(mpin):
                return True

        return False

    def check_mpin(self, mpin: str) -> Dict[str, Union[bool, str]]:
        """
        Check if the MPIN is weak and return result.

        Args:
            mpin (str): A 4-digit MPIN

        Returns:
            dict: Result containing strength status
        """
        is_weak = self.is_weak_mpin(mpin)

        result = {
            "mpin": mpin,
            "is_weak": is_weak,
            "strength": "WEAK" if is_weak else "STRONG"
        }

        return result


class EnhancedMPINValidator(MPINValidator):
    """
    Enhanced MPIN validator that considers user demographics
    in addition to pattern detection logic.
    """

    def __init__(self):
        """Initialize the enhanced validator"""
        super().__init__()
        self.demographic_patterns = set()

    def _extract_date_patterns(self, date_str: str) -> Set[str]:
        """
        Extract all possible 4-digit patterns from a date.

        Args:
            date_str (str): Date in DD-MM-YYYY format

        Returns:
            set: All possible 4-digit combinations from the date
        """
        if not date_str:
            return set()

        patterns = set()

        # Validate date format
        try:
            datetime.datetime.strptime(date_str, "%d-%m-%Y")
        except ValueError:
            print(f"⚠️ Invalid date skipped: {date_str}")
            return set()

        day, month, year = date_str.split("-")

        # Generate all possible combinations
        patterns.add(day + month)  # DDMM
        patterns.add(month + day)  # MMDD
        patterns.add(day + year[2:])  # DDYY
        patterns.add(month + year[2:])  # MMYY
        patterns.add(year[2:] + day)  # YYDD
        patterns.add(year[2:] + month)  # YYMM

        # For months/days less than 10, try without leading zeros
        day_no_zero = day.lstrip('0')
        month_no_zero = month.lstrip('0')

        # Only add if still 4 digits after combining without leading zeros
        if len(day_no_zero + month_no_zero) == 4:
            patterns.add(day_no_zero + month_no_zero)
        if len(month_no_zero + day_no_zero) == 4:
            patterns.add(month_no_zero + day_no_zero)

        # Add year as a pattern
        patterns.add(year)  # YYYY

        # Add last two digits of year repeated
        patterns.add(year[2:] * 2)  # YYYY (repeated last 2 digits)

        return patterns

    def set_demographics(self, dob: str = None, spouse_dob: str = None, anniversary: str = None):
        """
        Set user demographics for MPIN validation.

        Args:
            dob (str): Date of birth in DD-MM-YYYY format
            spouse_dob (str): Spouse's date of birth in DD-MM-YYYY format
            anniversary (str): Wedding anniversary in DD-MM-YYYY format
        """
        self.demographic_patterns = set()

        # Process DOB
        if dob:
            self.demographic_patterns.update(self._extract_date_patterns(dob))

        # Process spouse DOB
        if spouse_dob:
            self.demographic_patterns.update(self._extract_date_patterns(spouse_dob))

        # Process anniversary
        if anniversary:
            self.demographic_patterns.update(self._extract_date_patterns(anniversary))

    def is_demographic_match(self, mpin: str) -> bool:
        """Check if MPIN matches any demographic pattern"""
        return mpin in self.demographic_patterns

    def check_mpin(self, mpin: str) -> Dict[str, Union[bool, str]]:
        """
        Check if the MPIN is weak based on patterns or demographics.

        Args:
            mpin (str): A 4-digit MPIN

        Returns:
            dict: Result containing strength evaluation and explanation
        """
        # Basic validation
        if not isinstance(mpin, str) or not mpin.isdigit() or len(mpin) != 4:
            raise ValueError("MPIN must be a 4-digit string")

        # Check for patterns from parent class
        is_weak_pattern = self.is_weak_mpin(mpin)

        # Check for demographic matches
        is_demographic_match = self.is_demographic_match(mpin)

        # Determine overall strength
        is_weak = is_weak_pattern or is_demographic_match

        result = {
            "mpin": mpin,
            "strength": "WEAK" if is_weak else "STRONG",
            "is_weak_pattern": is_weak_pattern,
            "is_demographic_match": is_demographic_match
        }

        return result


class DetailedMPINValidator(EnhancedMPINValidator):
    """
    Detailed MPIN validator that provides specific reasons for weakness
    """

    def __init__(self):
        """Initialize the detailed validator"""
        super().__init__()
        self.dob = None
        self.spouse_dob = None
        self.anniversary = None

    def set_demographics(self, dob: str = None, spouse_dob: str = None, anniversary: str = None):
        """
        Set user demographics for MPIN validation with tracking.

        Args:
            dob (str): Date of birth in DD-MM-YYYY format
            spouse_dob (str): Spouse's date of birth in DD-MM-YYYY format
            anniversary (str): Wedding anniversary in DD-MM-YYYY format
        """
        # Store original dates for reference
        self.dob = dob
        self.spouse_dob = spouse_dob
        self.anniversary = anniversary

        # Generate demographic patterns
        self.dob_patterns = self._extract_date_patterns(dob) if dob else set()
        self.spouse_dob_patterns = self._extract_date_patterns(spouse_dob) if spouse_dob else set()
        self.anniversary_patterns = self._extract_date_patterns(anniversary) if anniversary else set()

        # Combine all patterns for general demographic matching
        self.demographic_patterns = set()
        self.demographic_patterns.update(self.dob_patterns)
        self.demographic_patterns.update(self.spouse_dob_patterns)
        self.demographic_patterns.update(self.anniversary_patterns)

    def check_mpin(self, mpin: str) -> Dict[str, Union[str, List[str]]]:
        """
        Check if the MPIN is weak and provide specific reasons.

        Args:
            mpin (str): A 4-digit MPIN

        Returns:
            dict: Result containing strength evaluation and weakness reasons
        """
        # Basic validation
        if not isinstance(mpin, str) or not mpin.isdigit() or len(mpin) != 4:
            raise ValueError("MPIN must be a 4-digit string")

        # Initialize result
        result = {
            "mpin": mpin,
            "strength": "STRONG",
            "reasons": []
        }

        # Check for common pattern
        if self.is_weak_mpin(mpin):
            result["strength"] = "WEAK"
            result["reasons"].append("COMMONLY_USED")

        # Check for demographic matches with specific reason codes
        if mpin in self.dob_patterns:
            result["strength"] = "WEAK"
            result["reasons"].append("DEMOGRAPHIC_DOB_SELF")

        if mpin in self.spouse_dob_patterns:
            result["strength"] = "WEAK"
            result["reasons"].append("DEMOGRAPHIC_DOB_SPOUSE")

        if mpin in self.anniversary_patterns:
            result["strength"] = "WEAK"
            result["reasons"].append("DEMOGRAPHIC_ANNIVERSARY")

        return result

    def get_demographic_info(self) -> Dict[str, str]:
        """Get the demographic information that's been set"""
        return {
            "dob": self.dob if self.dob else "Not provided",
            "spouse_dob": self.spouse_dob if self.spouse_dob else "Not provided",
            "anniversary": self.anniversary if self.anniversary else "Not provided"
        }


def main():
    """Test the detailed MPIN validator with user input"""
    validator = DetailedMPINValidator()

    print("=" * 50)
    print("OneBanc Detailed MPIN Validator - Part C")
    print("Check MPIN strength with specific weakness reasons")
    print("=" * 50)

    print("\nFirst, let's set your demographic information:")

    def get_valid_date(prompt: str) -> str:
        while True:
            date_input = input(prompt).strip()
            if not date_input:
                return ""
            try:
                datetime.datetime.strptime(date_input, "%d-%m-%Y")
                return date_input
            except ValueError:
                print("❌ Invalid date. Please enter a valid date in DD-MM-YYYY format.")

    dob = get_valid_date("Enter your date of birth (DD-MM-YYYY or leave blank): ")
    spouse_dob = get_valid_date("Enter spouse's date of birth (DD-MM-YYYY or leave blank): ")
    anniversary = get_valid_date("Enter wedding anniversary (DD-MM-YYYY or leave blank): ")

    validator.set_demographics(dob, spouse_dob, anniversary)

    while True:
        mpin = input("\nEnter a 4-digit MPIN to check (or 'q' to quit): ")

        if mpin.lower() == 'q':
            break

        try:
            result = validator.check_mpin(mpin)
            print(f"\nMPIN: {result['mpin']}")
            print(f"Strength: {result['strength']}")

            if result['reasons']:
                print("Weakness reasons:")
                for reason in result['reasons']:
                    print(f"- {reason}")
            else:
                print("This MPIN is strong and doesn't have any obvious weaknesses.")

        except ValueError as e:
            print(f"Error: {e}")


if __name__ == "__main__":
    print_onebanc_banner()
    main()