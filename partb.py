# -*- coding: utf-8 -*-
"""PartB.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WD3Fh4vOFHGoeKKtqMTrYQcy_TtO0oMM
"""

import datetime
from typing import Dict, Union, Set


def print_onebanc_banner():
    """Print the OneBanc MPIN Task banner"""
    banner = """
 ██████╗ ███╗   ██╗███████╗██████╗  █████╗ ███╗   ██╗ ██████╗
██╔═══██╗████╗  ██║██╔════╝██╔══██╗██╔══██╗████╗  ██║██╔════╝
██║   ██║██╔██╗ ██║█████╗  ██████╔╝███████║██╔██╗ ██║██║
██║   ██║██║╚██╗██║██╔══╝  ██╔══██╗██╔══██║██║╚██╗██║██║
╚██████╔╝██║ ╚████║███████╗██████╔╝██║  ██║██║ ╚████║╚██████╗
 ╚═════╝ ╚═╝  ╚═══╝╚══════╝╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═══╝ ╚═════╝

███╗   ███╗██████╗ ██╗███╗   ██╗    ██╗   ██╗ █████╗ ██╗     ██╗██████╗  █████╗ ████████╗ ██████╗ ██████╗
████╗ ████║██╔══██╗██║████╗  ██║    ██║   ██║██╔══██╗██║     ██║██╔══██╗██╔══██╗╚══██╔══╝██╔═══██╗██╔══██╗
██╔████╔██║██████╔╝██║██╔██╗ ██║    ██║   ██║███████║██║     ██║██║  ██║███████║   ██║   ██║   ██║██████╔╝
██║╚██╔╝██║██╔═══╝ ██║██║╚██╗██║    ╚██╗ ██╔╝██╔══██║██║     ██║██║  ██║██╔══██║   ██║   ██║   ██║██╔══██╗
██║ ╚═╝ ██║██║     ██║██║ ╚████║     ╚████╔╝ ██║  ██║███████╗██║██████╔╝██║  ██║   ██║   ╚██████╔╝██║  ██║
╚═╝     ╚═╝╚═╝     ╚═╝╚═╝  ╚═══╝      ╚═══╝  ╚═╝  ╚═╝╚══════╝╚═╝╚═════╝ ╚═╝  ╚═╝   ╚═╝    ╚═════╝ ╚═╝  ╚═╝
"""
    print(banner)


class MPINValidator:
    """
    Class to validate if a 4-digit MPIN is weak or strong.
    Uses pattern recognition techniques without hardcoding specific values.
    """

    def __init__(self):
        """Initialize the MPIN validator"""
        pass

    def is_weak_mpin(self, mpin: str) -> bool:
        """
        Determine if the provided MPIN is weak based on pattern analysis.

        Args:
            mpin (str): A 4-digit MPIN

        Returns:
            bool: True if the MPIN is weak, False if strong
        """
        # Basic validation
        if not isinstance(mpin, str) or not mpin.isdigit() or len(mpin) != 4:
            raise ValueError("MPIN must be a 4-digit string")

        # Check for weakness patterns

        # 1. Check if all digits are the same (e.g., 1111)
        if len(set(mpin)) == 1:
            return True

        # 2. Check for sequential ascending/descending patterns
        is_sequential = True
        difference = int(mpin[1]) - int(mpin[0])
        for i in range(1, len(mpin) - 1):
            if int(mpin[i+1]) - int(mpin[i]) != difference:
                is_sequential = False
                break
        if is_sequential and abs(difference) == 1:
            return True

        # 3. Check for repeating patterns (e.g., 1212, 1122)
        if len(set(mpin)) <= 2:
            return True

        # 4. Check for palindromes (e.g., 1221)
        if mpin == mpin[::-1]:
            return True

        # 5. Check for common year patterns (e.g., 19xx, 20xx)
        if (mpin[0:2] == "19" or mpin[0:2] == "20") and int(mpin[2:]) < 100:
            return True

        # Not matching any weak pattern, consider it strong
        return False

    def check_mpin(self, mpin: str) -> Dict[str, Union[bool, str]]:
        """
        Check if the MPIN is weak and return result.

        Args:
            mpin (str): A 4-digit MPIN

        Returns:
            dict: Result containing strength status
        """
        is_weak = self.is_weak_mpin(mpin)

        result = {
            "mpin": mpin,
            "is_weak": is_weak,
            "strength": "WEAK" if is_weak else "STRONG"
        }

        return result


class EnhancedMPINValidator(MPINValidator):
    """
    Enhanced MPIN validator that considers user demographics
    in addition to pattern detection logic.
    """

    def __init__(self):
        """Initialize the enhanced validator"""
        super().__init__()
        self.demographic_patterns = set()

    def _extract_date_patterns(self, date_str: str) -> Set[str]:
        """
        Extract all possible 4-digit patterns from a date.

        Args:
            date_str (str): Date in DD-MM-YYYY format

        Returns:
            set: All possible 4-digit combinations from the date
        """
        if not date_str:
            return set()

        patterns = set()

        # Validate date format
        try:
            datetime.datetime.strptime(date_str, "%d-%m-%Y")
        except ValueError:
            print(f"⚠️ Invalid date skipped: {date_str}")
            return set()

        day, month, year = date_str.split("-")

        # Generate all possible combinations
        patterns.add(day + month)  # DDMM
        patterns.add(month + day)  # MMDD
        patterns.add(day + year[2:])  # DDYY
        patterns.add(month + year[2:])  # MMYY
        patterns.add(year[2:] + day)  # YYDD
        patterns.add(year[2:] + month)  # YYMM

        # For months/days less than 10, try without leading zeros
        day_no_zero = day.lstrip('0')
        month_no_zero = month.lstrip('0')

        # Only add if still 4 digits after removing leading zeros
        if len(day_no_zero + month_no_zero) == 4:
            patterns.add(day_no_zero + month_no_zero)
        if len(month_no_zero + day_no_zero) == 4:
            patterns.add(month_no_zero + day_no_zero)

        # Add year as a pattern
        patterns.add(year)  # YYYY

        # Add last two digits of year repeated
        patterns.add(year[2:] * 2)  # YYYYYY (but only the last 4 digits)

        return patterns

    def set_demographics(self, dob: str = None, spouse_dob: str = None, anniversary: str = None):
        """
        Set user demographics for MPIN validation.

        Args:
            dob (str): Date of birth in DD-MM-YYYY format
            spouse_dob (str): Spouse's date of birth in DD-MM-YYYY format
            anniversary (str): Wedding anniversary in DD-MM-YYYY format
        """
        self.demographic_patterns = set()

        # Process DOB
        if dob:
            self.demographic_patterns.update(self._extract_date_patterns(dob))

        # Process spouse DOB
        if spouse_dob:
            self.demographic_patterns.update(self._extract_date_patterns(spouse_dob))

        # Process anniversary
        if anniversary:
            self.demographic_patterns.update(self._extract_date_patterns(anniversary))

    def is_demographic_match(self, mpin: str) -> bool:
        """Check if MPIN matches any demographic pattern"""
        return mpin in self.demographic_patterns

    def check_mpin(self, mpin: str) -> Dict[str, Union[bool, str]]:
        """
        Check if the MPIN is weak based on patterns or demographics.

        Args:
            mpin (str): A 4-digit MPIN

        Returns:
            dict: Result containing strength evaluation and explanation
        """
        # Basic validation
        if not isinstance(mpin, str) or not mpin.isdigit() or len(mpin) != 4:
            raise ValueError("MPIN must be a 4-digit string")

        # Check for patterns from parent class
        is_weak_pattern = self.is_weak_mpin(mpin)

        # Check for demographic matches
        is_demographic_match = self.is_demographic_match(mpin)

        # Determine overall strength
        is_weak = is_weak_pattern or is_demographic_match

        result = {
            "mpin": mpin,
            "strength": "WEAK" if is_weak else "STRONG",
            "is_weak_pattern": is_weak_pattern,
            "is_demographic_match": is_demographic_match
        }

        return result


def main():
    """Test the enhanced MPIN validator with user input"""
    validator = EnhancedMPINValidator()

    print("=" * 50)
    print("OneBanc Enhanced MPIN Validator - Part B")
    print("Check MPIN strength considering demographics")
    print("=" * 50)

    print("\nFirst, let's set your demographic information:")

    def get_valid_date(prompt: str) -> str:
        while True:
            date_input = input(prompt).strip()
            if not date_input:
                return ""
            try:
                datetime.datetime.strptime(date_input, "%d-%m-%Y")
                return date_input
            except ValueError:
                print("❌ Invalid date. Please enter a valid date in DD-MM-YYYY format.")

    dob = get_valid_date("Enter your date of birth (DD-MM-YYYY or leave blank): ")
    spouse_dob = get_valid_date("Enter spouse's date of birth (DD-MM-YYYY or leave blank): ")
    anniversary = get_valid_date("Enter wedding anniversary (DD-MM-YYYY or leave blank): ")

    validator.set_demographics(dob, spouse_dob, anniversary)

    while True:
        mpin = input("\nEnter a 4-digit MPIN to check (or 'q' to quit): ")

        if mpin.lower() == 'q':
            break

        try:
            result = validator.check_mpin(mpin)
            print(f"\nMPIN: {result['mpin']}")
            print(f"Strength: {result['strength']}")

            if result['is_weak_pattern']:
                print("This MPIN follows a common pattern and could be easily guessed.")
            if result['is_demographic_match']:
                print("This MPIN matches your demographic information.")

        except ValueError as e:
            print(f"Error: {e}")


if __name__ == "__main__":
    print_onebanc_banner()
    main()