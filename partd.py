# -*- coding: utf-8 -*-
"""PartD.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WD3Fh4vOFHGoeKKtqMTrYQcy_TtO0oMM
"""

import datetime
from typing import List, Dict, Union, Set
import math


def print_onebanc_banner():
    """Print the OneBanc MPIN Task banner"""
    banner = """
 ██████╗ ███╗   ██╗███████╗██████╗  █████╗ ███╗   ██╗ ██████╗
██╔═══██╗████╗  ██║██╔════╝██╔══██╗██╔══██╗████╗  ██║██╔════╝
██║   ██║██╔██╗ ██║█████╗  ██████╔╝███████║██╔██╗ ██║██║
██║   ██║██║╚██╗██║██╔══╝  ██╔══██╗██╔══██║██║╚██╗██║██║
╚██████╔╝██║ ╚████║███████╗██████╔╝██║  ██║██║ ╚████║╚██████╗
 ╚═════╝ ╚═╝  ╚═══╝╚══════╝╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═══╝ ╚═════╝

███╗   ███╗██████╗ ██╗███╗   ██╗    ██╗   ██╗ █████╗ ██╗     ██╗██████╗  █████╗ ████████╗ ██████╗ ██████╗
████╗ ████║██╔══██╗██║████╗  ██║    ██║   ██║██╔══██╗██║     ██║██╔══██╗██╔══██╗╚══██╔══╝██╔═══██╗██╔══██╗
██╔████╔██║██████╔╝██║██╔██╗ ██║    ██║   ██║███████║██║     ██║██║  ██║███████║   ██║   ██║   ██║██████╔╝
██║╚██╔╝██║██╔═══╝ ██║██║╚██╗██║    ╚██╗ ██╔╝██╔══██║██║     ██║██║  ██║██╔══██║   ██║   ██║   ██║██╔══██╗
██║ ╚═╝ ██║██║     ██║██║ ╚████║     ╚████╔╝ ██║  ██║███████╗██║██████╔╝██║  ██║   ██║   ╚██████╔╝██║  ██║
╚═╝     ╚═╝╚═╝     ╚═╝╚═╝  ╚═══╝      ╚═══╝  ╚═╝  ╚═╝╚══════╝╚═╝╚═════╝ ╚═╝  ╚═╝   ╚═╝    ╚═════╝ ╚═╝  ╚═╝
"""
    print(banner)


class MPINValidator:
    """
    Class to validate if a 6-digit MPIN is weak or strong based on pattern analysis.
    Uses only logical pattern detection techniques without predefined lists.
    """

    def __init__(self, pin_length=6):
        """Initialize the MPIN validator with pattern detection methods"""
        self.pin_length = pin_length

        # Define pattern detectors using only logic
        self.pattern_detectors = [
            self._is_sequential,
            self._is_repeated_digits,
            self._is_palindrome,
            self._is_all_same_digit,
            self._is_common_year,
            self._has_repeating_pattern,
            self._has_limited_unique_digits,
            self._is_all_even_or_odd,
            self._has_arithmetic_progression,
            self._has_symmetrical_pattern,
            self._has_digit_pairs
        ]

    def _is_sequential(self, mpin: str) -> bool:
        """
        Check if MPIN has sequential digits (ascending or descending).
        Uses logic to check if each digit differs from the previous by +1 or -1.
        """
        # Check for standard sequential patterns
        digits = [int(d) for d in mpin]

        # Check ascending (e.g., 123456, 456789)
        ascending = True
        for i in range(len(digits) - 1):
            if digits[i+1] != (digits[i] + 1) % 10:  # Use modulo for circular sequence (e.g., 890123)
                ascending = False
                break

        # Check descending (e.g., 654321, 987654)
        descending = True
        for i in range(len(digits) - 1):
            if digits[i+1] != (digits[i] - 1) % 10:  # Use modulo for circular sequence (e.g., 321098)
                descending = False
                break

        return ascending or descending

    def _is_repeated_digits(self, mpin: str) -> bool:
        """
        Check if MPIN has a repeating pattern like ABABAB or ABCABC.
        Uses logic to detect if patterns repeat within the MPIN.
        """
        # For 6-digit pins, check for patterns of length 2 or 3 (e.g., ABABAB or ABCABC)
        for pattern_length in range(1, (len(mpin) // 2) + 1):
            if len(mpin) % pattern_length == 0:  # Can be divided evenly
                pattern = mpin[:pattern_length]
                repetitions = len(mpin) // pattern_length

                if pattern * repetitions == mpin:
                    return True

        return False

    def _is_palindrome(self, mpin: str) -> bool:
        """
        Check if MPIN is a palindrome (reads the same backward as forward).
        Uses logic to test if the string equals its reverse.
        """
        return mpin == mpin[::-1]

    def _is_all_same_digit(self, mpin: str) -> bool:
        """
        Check if all digits in MPIN are the same.
        Uses logic to count unique digits.
        """
        return len(set(mpin)) == 1

    def _is_common_year(self, mpin: str) -> bool:
        """
        Check if MPIN represents a common year (19xx or 20xx).
        Uses logic to check if the PIN falls within a plausible year range.
        """
        # For 6-digit PIN, check for patterns like DDMMYY, MMDDYY, etc.
        if len(mpin) == 6:
            # Check for YYxxxx patterns (19xxxx or 20xxxx)
            prefixes = ['19', '20']
            for prefix in prefixes:
                if mpin.startswith(prefix):
                    year_part = mpin[:4]  # Get the year part
                    try:
                        year = int(year_part)
                        current_year = datetime.datetime.now().year
                        if 1930 <= year <= current_year:
                            return True
                    except ValueError:
                        pass

            # Check for xxxxYY patterns (xxxx19 or xxxx20)
            suffixes = ['19', '20']
            for suffix in suffixes:
                if mpin.endswith(suffix):
                    year_part = mpin[-4:]  # Get the year part
                    try:
                        year = int(year_part)
                        current_year = datetime.datetime.now().year
                        if 1930 <= year <= current_year:
                            return True
                    except ValueError:
                        pass
        return False

    def _has_repeating_pattern(self, mpin: str) -> bool:
        """
        Check for repeating patterns within the MPIN.
        Uses logic to detect patterns like AABBAABB, AABAAB, etc.
        """
        # Check for patterns where half of the MPIN equals the other half
        half_len = len(mpin) // 2
        if mpin[:half_len] == mpin[half_len:]:
            return True

        # Check for patterns where a digit occurs more than half the time
        for digit in set(mpin):
            if mpin.count(digit) > len(mpin) // 2:
                return True

        # Check for triple pairs (e.g., 112233)
        if len(mpin) == 6:
            if (mpin[0] == mpin[1]) and (mpin[2] == mpin[3]) and (mpin[4] == mpin[5]):
                return True

        return False

    def _has_limited_unique_digits(self, mpin: str) -> bool:
        """
        Check if MPIN has very few unique digits.
        Uses logic to count unique digits.
        """
        # For 6-digit MPIN, having 2 or fewer unique digits is very weak
        unique_count = len(set(mpin))

        # For a 6-digit pin, using only 1/3 or fewer of possible digits is weak
        max_expected_unique = min(10, self.pin_length)  # Maximum possible unique digits
        return unique_count <= max_expected_unique // 3

    def _is_all_even_or_odd(self, mpin: str) -> bool:
        """
        Check if all digits in the MPIN are either all even or all odd.
        """
        # Convert string to list of integers
        digits = [int(d) for d in mpin]

        # Check if all digits are even
        all_even = all(d % 2 == 0 for d in digits)

        # Check if all digits are odd
        all_odd = all(d % 2 == 1 for d in digits)

        return all_even or all_odd

    def _has_arithmetic_progression(self, mpin: str) -> bool:
        """
        Check if digits form an arithmetic progression (e.g., 246810, 864210).
        """
        digits = [int(d) for d in mpin]

        # Skip check if less than 3 unique digits (covered by other detectors)
        if len(set(digits)) < 3:
            return False

        # Check for constant difference between consecutive digits
        differences = [digits[i+1] - digits[i] for i in range(len(digits)-1)]

        # If all differences are the same and not 0, it's an arithmetic progression
        return len(set(differences)) == 1 and differences[0] != 0

    def _has_symmetrical_pattern(self, mpin: str) -> bool:
        """
        Check for symmetrical patterns like mirror patterns.
        """
        # For 6-digit pin: check if first and last digits match, second and second-to-last match, etc.
        for i in range(len(mpin) // 2):
            if mpin[i] != mpin[len(mpin) - 1 - i]:
                return False
        return True

    def _has_digit_pairs(self, mpin: str) -> bool:
        """
        Check if MPIN consists of digit pairs (e.g., 112233, 998877).
        """
        if len(mpin) % 2 != 0:  # Must have even length
            return False

        # Check if each pair is the same digit
        for i in range(0, len(mpin), 2):
            if mpin[i] != mpin[i+1]:
                return False

        # At least two different pairs for variety
        return len(set(mpin[::2])) > 1

    def _calculate_entropy(self, mpin: str) -> float:
        """
        Calculate Shannon entropy of the MPIN to measure randomness.
        Higher entropy indicates more randomness/strength.
        """
        # Count frequency of each digit
        freq = {}
        for digit in mpin:
            freq[digit] = freq.get(digit, 0) + 1

        # Calculate Shannon entropy
        length = len(mpin)
        entropy = 0.0

        for count in freq.values():
            probability = count / length
            entropy -= probability * math.log2(probability)

        # Calculate digit position entropy (transitions between digits)
        position_entropy = 0
        for i in range(len(mpin) - 1):
            if mpin[i] != mpin[i+1]:
                position_entropy += 1
        position_entropy = position_entropy / (len(mpin) - 1)  # Normalize

        # Combined score weighted toward unpredictability
        combined_entropy = (0.7 * entropy) + (0.3 * position_entropy)

        return combined_entropy

    def is_weak_mpin(self, mpin: str) -> bool:
        """
        Determine if the provided MPIN is weak based on pattern analysis.

        Args:
            mpin (str): A MPIN of specified length

        Returns:
            bool: True if the MPIN is weak, False if strong
        """
        # Basic validation
        if not isinstance(mpin, str) or not mpin.isdigit() or len(mpin) != self.pin_length:
            raise ValueError(f"MPIN must be a {self.pin_length}-digit string")

        # Run through pattern detectors
        for detector in self.pattern_detectors:
            if detector(mpin):
                return True

        # For 6-digit PINs, also check entropy
        if len(mpin) >= 6:
            # For longer pins, we expect higher entropy
            entropy_threshold = 2.0
            if self._calculate_entropy(mpin) < entropy_threshold:
                return True

        return False

    def check_mpin(self, mpin: str) -> Dict[str, Union[bool, str]]:
        """
        Check if the MPIN is weak and return result.

        Args:
            mpin (str): A MPIN of specified length

        Returns:
            dict: Result containing strength status
        """
        is_weak = self.is_weak_mpin(mpin)

        result = {
            "mpin": mpin,
            "is_weak": is_weak,
            "strength": "WEAK" if is_weak else "STRONG"
        }

        return result


class EnhancedMPINValidator(MPINValidator):
    """
    Enhanced MPIN validator that considers user demographics
    in addition to pattern detection logic.
    """

    def __init__(self, pin_length=6):
        """Initialize the enhanced validator"""
        super().__init__(pin_length)
        self.demographic_patterns = set()

    def _extract_date_patterns(self, date_str: str) -> Set[str]:
        """
        Extract all possible patterns from a date that match the PIN length.

        Args:
            date_str (str): Date in DD-MM-YYYY format

        Returns:
            set: All possible combinations from the date that match PIN length
        """
        if not date_str:
            return set()

        patterns = set()

        # Validate date format
        try:
            datetime.datetime.strptime(date_str, "%d-%m-%Y")
        except ValueError:
            print(f"⚠️ Invalid date skipped: {date_str}")
            return set()

        day, month, year = date_str.split("-")

        # For 6-digit PINs, generate appropriate patterns
        if self.pin_length == 6:
            # Full combinations
            patterns.add(day + month + year[2:])  # DDMMYY
            patterns.add(month + day + year[2:])  # MMDDYY
            patterns.add(year[2:] + month + day)  # YYMMDD
            patterns.add(day + year[2:] + month)  # DDYYMM
            patterns.add(month + year[2:] + day)  # MMYYDD
            patterns.add(year[2:] + day + month)  # YYDDMM

            # Repeated patterns
            patterns.add(day + month + day)       # DDMMDD
            patterns.add(month + day + month)     # MMDDMM
            patterns.add(year[2:] + year[2:] + year[2:])  # YYYYYY

            # For months/days less than 10, try without leading zeros
            day_no_zero = day.lstrip('0')
            if day_no_zero == '':  # Handle case where day is '00'
                day_no_zero = '0'

            month_no_zero = month.lstrip('0')
            if month_no_zero == '':  # Handle case where month is '00'
                month_no_zero = '0'

            # Add patterns with cleaned day/month if still 6 digits
            if len(day_no_zero + month_no_zero + year[2:]) == 6:
                patterns.add(day_no_zero + month_no_zero + year[2:])
            if len(month_no_zero + day_no_zero + year[2:]) == 6:
                patterns.add(month_no_zero + day_no_zero + year[2:])
            if len(year[2:] + day_no_zero + month_no_zero) == 6:
                patterns.add(year[2:] + day_no_zero + month_no_zero)

            # Full year patterns if applicable
            patterns.add(year)  # YYYY
            if len(year) + len(day) == 6:
                patterns.add(year + day)
            if len(year) + len(month) == 6:
                patterns.add(year + month)

        # Filter to only include patterns that match the PIN length
        return {p for p in patterns if len(p) == self.pin_length}

    def set_demographics(self, dob: str = None, spouse_dob: str = None, anniversary: str = None):
        """
        Set user demographics for MPIN validation.

        Args:
            dob (str): Date of birth in DD-MM-YYYY format
            spouse_dob (str): Spouse's date of birth in DD-MM-YYYY format
            anniversary (str): Wedding anniversary in DD-MM-YYYY format
        """
        self.demographic_patterns = set()

        # Process DOB
        if dob:
            self.demographic_patterns.update(self._extract_date_patterns(dob))

        # Process spouse DOB
        if spouse_dob:
            self.demographic_patterns.update(self._extract_date_patterns(spouse_dob))

        # Process anniversary
        if anniversary:
            self.demographic_patterns.update(self._extract_date_patterns(anniversary))

    def is_demographic_match(self, mpin: str) -> bool:
        """Check if MPIN matches any demographic pattern"""
        return mpin in self.demographic_patterns

    def check_mpin(self, mpin: str) -> Dict[str, Union[bool, str]]:
        """
        Check if the MPIN is weak based on patterns or demographics.

        Args:
            mpin (str): A MPIN of specified length

        Returns:
            dict: Result containing strength evaluation and explanation
        """
        # Basic validation
        if not isinstance(mpin, str) or not mpin.isdigit() or len(mpin) != self.pin_length:
            raise ValueError(f"MPIN must be a {self.pin_length}-digit string")

        # Check for patterns from parent class
        is_weak_pattern = self.is_weak_mpin(mpin)

        # Check for demographic matches
        is_demographic_match = self.is_demographic_match(mpin)

        # Determine overall strength
        is_weak = is_weak_pattern or is_demographic_match

        result = {
            "mpin": mpin,
            "strength": "WEAK" if is_weak else "STRONG",
            "is_weak_pattern": is_weak_pattern,
            "is_demographic_match": is_demographic_match
        }

        return result


class DetailedMPINValidator(EnhancedMPINValidator):
    """
    Detailed MPIN validator that provides specific reasons for weakness
    """

    def __init__(self, pin_length=6):
        """Initialize the detailed validator"""
        super().__init__(pin_length)
        self.dob = None
        self.spouse_dob = None
        self.anniversary = None

    def set_demographics(self, dob: str = None, spouse_dob: str = None, anniversary: str = None):
        """
        Set user demographics for MPIN validation with tracking.

        Args:
            dob (str): Date of birth in DD-MM-YYYY format
            spouse_dob (str): Spouse's date of birth in DD-MM-YYYY format
            anniversary (str): Wedding anniversary in DD-MM-YYYY format
        """
        # Store original dates for reference
        self.dob = dob
        self.spouse_dob = spouse_dob
        self.anniversary = anniversary

        # Generate demographic patterns
        self.dob_patterns = self._extract_date_patterns(dob) if dob else set()
        self.spouse_dob_patterns = self._extract_date_patterns(spouse_dob) if spouse_dob else set()
        self.anniversary_patterns = self._extract_date_patterns(anniversary) if anniversary else set()

        # Combine all patterns for general demographic matching
        self.demographic_patterns = set()
        self.demographic_patterns.update(self.dob_patterns)
        self.demographic_patterns.update(self.spouse_dob_patterns)
        self.demographic_patterns.update(self.anniversary_patterns)

    def check_mpin(self, mpin: str) -> Dict[str, Union[str, List[str]]]:
        """
        Check if the MPIN is weak and provide specific reasons.

        Args:
            mpin (str): A MPIN of specified length

        Returns:
            dict: Result containing strength evaluation and weakness reasons
        """
        # Basic validation
        if not isinstance(mpin, str) or not mpin.isdigit() or len(mpin) != self.pin_length:
            raise ValueError(f"MPIN must be a {self.pin_length}-digit string")

        # Initialize result
        result = {
            "mpin": mpin,
            "strength": "STRONG",
            "reasons": []
        }

        # Check for common pattern
        if super(EnhancedMPINValidator, self).is_weak_mpin(mpin):
            result["strength"] = "WEAK"
            result["reasons"].append("COMMONLY_USED")

        # Check for demographic matches with specific reason codes
        if mpin in self.dob_patterns:
            result["strength"] = "WEAK"
            result["reasons"].append("DEMOGRAPHIC_DOB_SELF")

        if mpin in self.spouse_dob_patterns:
            result["strength"] = "WEAK"
            result["reasons"].append("DEMOGRAPHIC_DOB_SPOUSE")

        if mpin in self.anniversary_patterns:
            result["strength"] = "WEAK"
            result["reasons"].append("DEMOGRAPHIC_ANNIVERSARY")

        # Include entropy assessment for 6-digit PINs
        if len(mpin) >= 6:
            entropy_score = self._calculate_entropy(mpin)
            # Add entropy score to results
            result["entropy_score"] = round(entropy_score, 2)

            # Only add low entropy reason if it's not already weak
            if entropy_score < 2.0 and not result["reasons"]:
                result["strength"] = "WEAK"
                result["reasons"].append("COMMONLY_USED")  # Using standard reason code

        return result

    def get_demographic_info(self) -> Dict[str, str]:
        """Get the demographic information that's been set"""
        return {
            "dob": self.dob if self.dob else "Not provided",
            "spouse_dob": self.spouse_dob if self.spouse_dob else "Not provided",
            "anniversary": self.anniversary if self.anniversary else "Not provided"
        }


class SixDigitMPINValidator(DetailedMPINValidator):
    """
    Specialized validator for 6-digit MPINs using logic-based pattern detection
    """

    def __init__(self):
        """Initialize the 6-digit MPIN validator"""
        super().__init__(pin_length=6)

        # Add specialized 6-digit detectors
        self.pattern_detectors.extend([
            self._has_repeated_triplets,
            self._has_date_pattern,
            self._has_repeating_sequence
        ])

    def _has_repeated_triplets(self, mpin: str) -> bool:
        """Check if the 6-digit MPIN consists of the same 3 digits repeated"""
        if len(mpin) == 6:
            return mpin[:3] == mpin[3:6]
        return False

    def _has_date_pattern(self, mpin: str) -> bool:
        """
        Check if MPIN follows common date patterns (DDMMYY, MMDDYY, etc.)
        without using predefined lists
        """
        if len(mpin) == 6:
            # Try various date combinations
            potential_dates = [
                mpin[:2] + "-" + mpin[2:4] + "-" + "20" + mpin[4:],  # DDMMYY
                mpin[2:4] + "-" + mpin[:2] + "-" + "20" + mpin[4:],  # MMDDYY
                "20" + mpin[:2] + "-" + mpin[2:4] + "-" + mpin[4:],  # YYMMDD
            ]

            for date_str in potential_dates:
                try:
                    date = datetime.datetime.strptime(date_str, "%d-%m-%Y")
                    current_year = datetime.datetime.now().year
                    # Check if date is within a reasonable range
                    if 1930 <= date.year <= current_year + 5:
                        return True
                except ValueError:
                    # Invalid date, try next pattern
                    continue
        return False

    def _has_repeating_sequence(self, mpin: str) -> bool:
        """Check for repeating sequences in 6-digit MPIN"""
        # Check for patterns where a sub-sequence repeats
        for seq_len in range(1, len(mpin)//2 + 1):
            if len(mpin) % seq_len == 0:  # Can be evenly divided
                is_repeating = True
                base_sequence = mpin[:seq_len]

                for i in range(seq_len, len(mpin), seq_len):
                    if mpin[i:i+seq_len] != base_sequence:
                        is_repeating = False
                        break

                if is_repeating:
                    return True

        return False

    def check_mpin(self, mpin: str) -> Dict[str, Union[str, List[str]]]:
        """
        Check if the 6-digit MPIN is weak and provide specific reasons.

        Args:
            mpin (str): A 6-digit MPIN

        Returns:
            dict: Result containing strength evaluation and weakness reasons
        """
        # Use parent class logic but ensure proper validation for 6 digits
        if not isinstance(mpin, str) or not mpin.isdigit() or len(mpin) != 6:
            raise ValueError("MPIN must be a 6-digit string")

        # Get basic result from parent class
        result = super().check_mpin(mpin)

        # Add entropy score
        entropy_score = self._calculate_entropy(mpin)
        result["entropy_score"] = round(entropy_score, 2)

        return result


def main():
    """Test the 6-digit MPIN validator with user input"""
    validator = SixDigitMPINValidator()

    print("=" * 50)
    print("OneBanc 6-Digit MPIN Validator - Part D")
    print("Check MPIN strength with specific weakness reasons")
    print("=" * 50)

    print("\nFirst, let's set your demographic information:")

    def get_valid_date(prompt: str) -> str:
        while True:
            date_input = input(prompt).strip()
            if not date_input:
                return ""
            try:
                datetime.datetime.strptime(date_input, "%d-%m-%Y")
                return date_input
            except ValueError:
                print("❌ Invalid date. Please enter a valid date in DD-MM-YYYY format.")

    dob = get_valid_date("Enter your date of birth (DD-MM-YYYY or leave blank): ")
    spouse_dob = get_valid_date("Enter spouse's date of birth (DD-MM-YYYY or leave blank): ")
    anniversary = get_valid_date("Enter wedding anniversary (DD-MM-YYYY or leave blank): ")

    validator.set_demographics(dob, spouse_dob, anniversary)

    while True:
        mpin = input("\nEnter a 6-digit MPIN to check (or 'q' to quit): ")

        if mpin.lower() == 'q':
            break

        try:
            result = validator.check_mpin(mpin)
            print(f"\nMPIN: {result['mpin']}")
            print(f"Strength: {result['strength']}")

            # Show entropy score
            if "entropy_score" in result:
                print(f"Entropy Score: {result['entropy_score']}")

            if result['reasons']:
                print("Weakness reasons:")
                for reason in result['reasons']:
                    print(f"- {reason}")
            else:
                print("This MPIN is strong and doesn't have any obvious weaknesses.")

        except ValueError as e:
            print(f"Error: {e}")


if __name__ == "__main__":
    print_onebanc_banner()
    main()